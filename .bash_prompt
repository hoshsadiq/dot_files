#!/usr/bin/env bash
ps1_smiley() {
  echo -n "─["
  if [[ "$?" = "0" ]]; then
    echo -ne "${_color_green}^_^${_color_end}";
  else
    echo -ne "${_color_red}O_O${_color_end}";
  fi
  echo -n "]"
}

ps1_pwd() {
  printf "%s" "─[${_color_bright_blue}\W${_color_end}]"
}

ps1_identity() {
  echo -n "─["

  # user color
  if [[ ${USER} == "root" ]]; then
     echo -ne "${_color_red}"
  elif [[ ${USER} != $(logname) ]]; then
     echo -ne "${_color_bright_red}"
  else
     echo -ne "${_color_green}"
  fi

  echo -ne "\u${_color_end}" # username
  echo -ne "@${_color_cyan}\h${_color_end}" # @hostname
  echo -n "]"
}

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
_ps1_jobcount_color()
{
  local running=$(( $(jobs -r | wc -l) ))
  local stopped=$(( $(jobs -s | wc -l) ))
  local n_screen=$(screen -ls 2> /dev/null | grep -c Detach)
  local ret=""

  if [[ $n_screen != "0" ]] ; then
      ret="${ret}${_color_yellow}${n_screen}d${_color_end}"
  fi

  if [[ $running != "0" ]] ; then
      if [[ $ret != "" ]] ; then ret="${ret}:"; fi
      ret="${ret}${_color_yellow}${running}&${_color_end}"
  fi

  if [[ $stopped != "0" ]] ; then
      if [[ $ret != "" ]] ; then ret="${ret}:"; fi
      ret="${ret}${_color_yellow}${stopped}z${_color_end}"
  fi

  if [[ $ret != "" ]]; then
    ret="─[${ret}]"
  fi
  echo -ne "$ret"
}

_ps1_permissions_color()
{
  echo -n "\$"
  return
  if [[ -w "${PWD}" ]]; then
      echo -ne "${_color_green}\$${_color_end}"
  else
      echo -ne "${_color_red}\$${_color_end}"
  fi
}

ps1_git()
{
  local branch="" sha1="" line="" gitColor="" remote="" branch_color=""
  local behind="" ahead="" ahead_behind="" git_status="" status_chars=""
  local gitdir="" conflicts=0

  shopt -s extglob # Important, for our nice matchers :)

  if ! command -v git >/dev/null 2>&1 && [[ -d ./.git ]]; then
    printf " \033[1;37m\033[41m[git not found]\033[m "
    return 0
  fi

  # get the branch name
  # gitdir="$([ $(git ls-files . 2>/dev/null | wc -l) -gt 0 ] && git rev-parse --git-dir 2>/dev/null)"
  # [[ $? -ne 0 || ! $gitdir =~ (.*\/)?\.git.* ]] && return
  # branch="$(git symbolic-ref HEAD 2>/dev/null)"
  # if [[ $? -ne 0 || -z "$branch" ]] ; then
  #     # In detached head state, use commit instead
  #     branch="$(git rev-parse --short HEAD 2>/dev/null)❍"
  # fi
  branch="$(git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)"

  [[ $? -ne 0 || -z "$branch" ]] && return

  branch="${branch#refs/heads/}"

  # branch name and color first
  case "${branch:-"(no branch)"}" in
   production|prod)         branch_color="${_color_red}"        ;; # red
   master|deploy)           branch_color="${_color_red}"        ;; # red
   stage|staging)           branch_color="${_color_yellow}"     ;; # yellow
   dev|develop|development) branch_color="${_color_blue}"       ;; # blue
   next)                    branch_color="${_color_cyan}"       ;; # gray
   *)                       branch_color="${_color_green}"      ;; # green
  esac
  branch_color="${branch_color}${branch}${_color_end}"

  # are we behind or ahead?
  remote="$(git config --get branch.${branch}.remote 2>/dev/null)"
  behind=$(git log --oneline HEAD..${remote} | wc -l)
  ahead=$(git log --oneline ${remote}..HEAD | wc -l)
  conflicts="$(git diff --name-only --diff-filter=U | wc -l)"
  [[ $behind -gt 0 ]]           && ahead_behind="${_color_red}↓${behind}${_color_end}"
  [[ $ahead -gt 0 ]]            && ahead_behind="${ahead_behind}${_color_green}↑${ahead}${_color_end}"
  [[ $conflicts -gt 0 ]]        && ahead_behind="${ahead_behind}${_color_bg_red}❗${conflicts}${_color_end}"
  [[ "$ahead_behind" != "" ]]   && ahead_behind=":${ahead_behind}"

  # git the current status
  git_status="$(git status 2>/dev/null)"

  [[ "${git_status}" = *modified:* ]]                  && status_chars="${_color_yellow}*${_color_end}"
  [[ "${git_status}" = *deleted* ]]                    && status_chars="${status_chars}${_color_red}✘${_color_end}"
  [[ "${git_status}" = *Untracked[[:space:]]files:* ]] && status_chars="${status_chars}${_color_green}+${_color_end}"
  [[ -n "$(git stash list 2>/dev/null)" ]]             && status_chars="${status_chars}${_color_yellow}…${_color_end}"
  if [[ "$status_chars" != "" ]]; then
    status_chars=":${status_chars}"
  elif [[ "$ahead_behind" == "" ]]; then
    status_chars="${_color_green}✔${_color_end}"
  fi

  printf "─[${branch_color}${ahead_behind}${status_chars}]"
}

ps1_titlebar()
{
  case $TERM in
    (xterm*|rxvt*)
      printf "%s" "\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]"
      ;;
    # (screen)
    #     printf "\033k%s\033\\" "\W"
    #     screen -X eval "at \\# title \W" "shelltitle \W"
    #   ;;
  esac
}


export PS1="$(ps1_titlebar)\n┌$(ps1_identity)\$(ps1_smiley)\$(_ps1_jobcount_color)$(ps1_pwd)\$(ps1_git)\n└\$(_ps1_permissions_color) "
export PS2="  \[\033[0;40m\]\[\033[0;33m\]> \[\033[1;37m\]\[\033[1m\]"
export PS4="+ \${FUNCNAME[0]:+\${FUNCNAME[0]}()}  \${LINENO} > "
