#!/usr/bin/env bash
ps1_smiley() {
  echo -n "─["
  if [[ "$?" = "0" ]]; then
    echo -ne "${_color_green}^_^${_color_end}";
  else
    echo -ne "${_color_red}O_O${_color_end}";
  fi
  echo -n "]"
}

function _ps1_realpath()
{
    f="$1"
 
    if [ -d $f ]; then
        base=""
        dir="$f"
    else
        base="/$(basename $f)"
        dir="$(dirname $f)"
    fi
 
    dir=$(cd $dir && pwd)
 
    echo "$dir$base"
}
 
# Set prompt path to max 2 levels for best compromise of readability and usefulness
_ps1_pwd () {

  realpwd="$(_ps1_realpath $PWD)"
  realhome="$(_ps1_realpath $HOME)"

  echo -ne "─[${_color_bright_blue}"
  # if we are in the home directory
  if echo $realpwd | grep -q "^$realhome"; then
      path=$(echo $realpwd | sed "s|^$realhome|\~|")

      if [ "$path" = "~" ] || [ $(dirname "$path") = "~" ]; then
          echo -n "$path"
      else
          echo -n $(basename "$(dirname $path)")/$(basename "$path")
      fi
      echo -ne "${_color_end}]"
      return
  fi

  # npwd="$PWD"
  # if [[ "$OSTYPE" == "cygwin" ]]; then
  #     npwd=$(echo $npwd | sed -r "s|^/cygdrive/([a-z]+)|\U\1:|")
  # fi

  path_dir="$(dirname "$npwd")"

  # if our parent dir is a top-level directory, don't mangle it
  if [ "$(dirname $path_dir)" = "/" ]; then
      echo -n "$PWD"
  else
      path_parent="$(basename "$path_dir")"
      path_base="$(basename "$PWD")"

      echo -n "$path_parent/$path_base"
  fi
  echo -ne "${_color_end}]"
}


_ps1_identity() {
  echo -n "─["

  # user color
  if [[ ${USER} == "root" ]]; then
     echo -ne "${_color_red}"
  elif [[ ${USER} != $(logname) ]]; then
     echo -ne "${_color_bright_red}"
  else
     echo -ne "${_color_green}"
  fi

  echo -ne "\u${_color_end}" # username
  echo -ne "@${_color_cyan}\h${_color_end}" # @hostname
  echo -n "]"
}

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
_ps1_jobcount_color()
{
  local running=$(( $(jobs -r | wc -l) ))
  local stopped=$(( $(jobs -s | wc -l) ))
  # local n_screen=$(screen -ls 2> /dev/null | grep -c Detach)
  local n_screen=0
  local ret=""

  if [[ $n_screen != "0" ]] ; then
      ret="${ret}${_color_yellow}${n_screen}d${_color_end}"
  fi

  if [[ $running != "0" ]] ; then
      if [[ $ret != "" ]] ; then ret="${ret}:"; fi
      ret="${ret}${_color_yellow}${running}&${_color_end}"
  fi

  if [[ $stopped != "0" ]] ; then
      if [[ $ret != "" ]] ; then ret="${ret}:"; fi
      ret="${ret}${_color_yellow}${stopped}z${_color_end}"
  fi

  if [[ $ret != "" ]]; then
    ret="─[${ret}]"
  fi
  echo -ne "$ret"
}

_ps1_permissions_color()
{
  echo -n "\$"
  return
  if [[ -w "${PWD}" ]]; then
      echo -ne "${_color_green}\$${_color_end}"
  else
      echo -ne "${_color_red}\$${_color_end}"
  fi
}

_ps1_git()
{
  local branch="" sha1="" line="" gitColor="" remote="" branch_color=""
  local behind="" ahead="" ahead_behind="" git_status="" status_chars=""
  local gitdir="" conflicts=0

  shopt -s extglob # Important, for our nice matchers :)

  if ! command -v git >/dev/null 2>&1 && [[ -d ./.git ]]; then
    printf " \033[1;37m\033[41m[git not found]\033[m "
    return 0
  fi

  # get the branch name
  # gitdir="$([ $(git ls-files . 2>/dev/null | wc -l) -gt 0 ] && git rev-parse --git-dir 2>/dev/null)"
  # [[ $? -ne 0 || ! $gitdir =~ (.*\/)?\.git.* ]] && return
  # branch="$(git symbolic-ref HEAD 2>/dev/null)"
  # if [[ $? -ne 0 || -z "$branch" ]] ; then
  #     # In detached head state, use commit instead
  #     branch="$(git rev-parse --short HEAD 2>/dev/null)❍"
  # fi
  branch="$(git symbolic-ref HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)"

  [[ $? -ne 0 || -z "$branch" ]] && return

  branch="${branch#refs/heads/}"

  # branch name and color first
  case "${branch:-"(no branch)"}" in
   production|prod)         branch_color="${_color_red}"        ;; # red
   master|deploy)           branch_color="${_color_red}"        ;; # red
   stage|staging)           branch_color="${_color_yellow}"     ;; # yellow
   dev|develop|development) branch_color="${_color_blue}"       ;; # blue
   next)                    branch_color="${_color_cyan}"       ;; # gray
   *)                       branch_color="${_color_green}"      ;; # green
  esac
  branch_color="${branch_color}${branch}${_color_end}"

  # are we behind or ahead?
  remote="$(git config --get branch.${branch}.remote 2>/dev/null)"
  behind=$(git log --oneline HEAD..${remote} 2>/dev/null | wc -l)
  ahead=$(git log --oneline ${remote}..HEAD 2>/dev/null | wc -l)
  conflicts="$(git diff --name-only --diff-filter=U | wc -l)"
  [[ $behind -gt 0 ]]           && ahead_behind="${_color_red}↓${behind}${_color_end}" # arrow down means behind
  [[ $ahead -gt 0 ]]            && ahead_behind="${ahead_behind}${_color_green}↑${ahead}${_color_end}" # arrow up means ahead
  [[ $conflicts -gt 0 ]]        && ahead_behind="${ahead_behind}${_color_bg_red}❗${conflicts}${_color_end}" # exclamation means conflicts
  [[ "$ahead_behind" != "" ]]   && ahead_behind=":${ahead_behind}"

  # git the current status
  git_status="$(git status 2>/dev/null)"

  [[ "${git_status}" = *modified:* ]]                  && status_chars="${_color_yellow}*${_color_end}" # star means modified files
  [[ "${git_status}" = *deleted* ]]                    && status_chars="${status_chars}${_color_red}✘${_color_end}" # cross means deleted files
  [[ "${git_status}" = *Untracked[[:space:]]files:* ]] && status_chars="${status_chars}${_color_green}+${_color_end}" # plus means added files
  [[ -n "$(git stash list 2>/dev/null)" ]]             && status_chars="${status_chars}${_color_yellow}…${_color_end}" # multidots means we have code stashed

  # separate status characters
  if [[ "$status_chars" != "" ]]; then
    status_chars=":${status_chars}"
  elif [[ "$ahead_behind" == "" ]]; then
    status_chars="${_color_green}✔${_color_end}" # clean repo means green tickmark!
  fi

  printf "─[${branch_color}${ahead_behind}${status_chars}]"
}

_ps1_titlebar()
{
  case $TERM in
    (xterm*|rxvt*)
      printf "%s" "\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]"
      ;;
    # (screen)
    #     printf "\033k%s\033\\" "\W"
    #     screen -X eval "at \\# title \W" "shelltitle \W"
    #   ;;
  esac
}


export PS1="$(_ps1_titlebar)\n┌$(_ps1_identity)\$(ps1_smiley)\$(_ps1_jobcount_color)\$(_ps1_pwd)\$(_ps1_git)\n└\$(_ps1_permissions_color) "
export PS2="  \[\033[0;40m\]\[\033[0;33m\]> \[\033[1;37m\]\[\033[1m\]"
export PS4="+ \${FUNCNAME[0]:+\${FUNCNAME[0]}()}  \${LINENO} > "
