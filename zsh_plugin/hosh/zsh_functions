diff() {
    git diff --no-index --color-words "$@";
}

# sgviz() {
#   vpcIds="$1"
#   outputFileName="$2"
#   outputFileName="$2"
#
#   docker run --rm -it --name tmp-sgviz \
#       -v $HOME/.aws:/root/.aws \
#       -v $(pwd):/workdir \
#       sgviz \
#
#       generate \
#         --vpc-ids "$vpcIds" \
#         --output-path /workdir/$outputFileName \
#         --region "$region" \
#         --profile sandbox
# }

aws-params-to-args() {
  yaml2json "$1" | jq -r 'map("ParameterKey=\(.ParameterKey),ParameterValue=\(.ParameterValue)") | join(" ")'
}

aws-export-session-env() {
  profile="$1"

  if [ -z "$profile" ]; then
    echo "usage:"
    echo "  $0 <profile>"
    echo "Note this clears all sessions and only keeps the newly created session"
    return 1
  fi

  # rm -rf $HOME/.aws/cli/cache/*.json
  calledIdentity="$(aws sts get-caller-identity --profile "$profile")"
  assumedRoleId="$(echo "$calledIdentity" | jq -r '.UserId')"
  account="$(echo "$calledIdentity" | jq -r '.Account')"
  arn="$(echo "$calledIdentity" | jq -r '.Arn')"
  if ! beginsWith "arn:aws:sts::${account}:assumed-role/" "$arn"; then
    echo 'This utility ony works with assumed-roles for now'
    return 0
  fi

  for sessionFile in $HOME/.aws/cli/cache/*.json; do
    sessionAssumedRoleId="$(jq -r '.AssumedRoleUser.AssumedRoleId' $sessionFile)"
    sessionArn="$(jq -r '.AssumedRoleUser.Arn' $sessionFile)"

    if [ "$sessionAssumedRoleId" = "$assumedRoleId" -a "$sessionArn" = "$arn" ]; then
      export AWS_ACCESS_KEY_ID="$(jq -r '.Credentials.AccessKeyId' "$sessionFile")"
      export AWS_SECRET_ACCESS_KEY="$(jq -r '.Credentials.SecretAccessKey' "$sessionFile")"
      export AWS_SESSION_TOKEN="$(jq -r '.Credentials.SessionToken' "$sessionFile")"
    fi
  done
}

stringContains() { [ -z "${2##*$1*}" ] }

beginsWith() { case $2 in "$1"*) true;; *) false;; esac; }

ssh-priv-to-pub() {
  sshPrivKey="$1"
  ssh-keygen -y -f "$sshPrivKey"
}

ssh-gen-deploy-key() {
  output="$1"
  comment="$2"
  bytes="${3:-4096}"

  if [ ! -z "$comment" ]; then
    comment="-C $comment"
  fi
  ssh-keygen -t rsa -b "$bytes" -f "$output" -N '' $comment
}

ssh-get-fingerprint() {
  keyFile="$1" # can be either public or private key
  hash="${2:-md5}"
  ssh-keygen -E "$hash" -lf "$keyFile"
}

download-helm-chart() {
    chart="$1"
    targetDir="$2"

    if [ "$chart" = "" ] && [ "$targetDir" = "" ]; then
        echo "Usage: $0 <chart-name> <target-dir>"
    fi

    tmpdir="$(mktemp -d -t helm)"

    curl -sSL -o "$tmpdir/helm-charts.zip" https://github.com/kubernetes/charts/archive/master.zip

    unzip "$tmpdir/helm-charts.zip" "charts-master/stable/$chart*" -d $tmpdir
    mv "$tmpdir/charts-master/stable/$chart" "$targetDir/$chart-helm-chart"
}

kubectl_pod() {
    # todo add --namespace support
    kubectl get pods | awk "/^$1/{print \$1}"
}

proxy() {
  action="$1"

  if [ $action = "enable" ]; then
    export http_proxy="http://uk-webproxy.edmz.tesco.org:80"
    export https_proxy="http://uk-webproxy.edmz.tesco.org:80"
    echo "Proxy enabled"
  elif [ "$action" = "disable" ]; then
    export http_proxy=""
    export https_proxy=""
    echo "Proxy disabled"
  else
    echo "$0 enable|disable"
  fi
}

vault_encrypt() {
    file="$1"

    if [ -z "$file" ]; then
        echo "Usage:"
        echo "  $0 /path/to/file"
        return 1
    fi

    if [ ! -f "$file" ]; then
        echo "file $file does not exist"
        return 1
    fi

    if [ -f "$file.enc" ]; then
      encryptedData="$(ansible-vault decrypt --vault-password-file=~/.vault-credentials --output - "$file.enc")"
      unencryptedData="$(cat "$file")"

      if cmp -s <(echo $encryptedData) <(echo $unencryptedData); then
        echo "Encrypted file is identical to unencrypted file... skipping"
        return 1
      fi
    fi

    ansible-vault encrypt --vault-password-file=~/.vault-credentials --output "$file.enc" "$file"
}

vault_decrypt() {
    file="$1"

    if [ -z "$file" ]; then
        echo "Usage:"
        echo "  $0 /path/to/file"
        return 1
    fi

    if [ ! -f "$file.enc" ]; then
        echo "file $file.enc does not exist"
        return 1
    fi

    ansible-vault decrypt --vault-password-file=~/.vault-credentials --output "$file" "$file.enc"
}

check_gpg_pass() {
    if [ "$1x" == "x" ]; then
        echo "check_gpg_pass <key-id>"
        return 1
    fi
    echo "1234" | gpg --batch -o /dev/null --local-user "$1" -as - 2>&1 && echo "The correct passphrase was entered for this key"
}

remux_mkv2mp4() {
  input="$1"
  ext="$(echo $input | awk -F. '{print $NF}')"

  if [ "$ext" != "mkv" ]; then
    print "Input file must be of type .mkv"
  fi

  dir="$(dirname $input)"
  output="$dir/$(basename $input ".mkv").mp4"
  ffmpeg -i "$input" -c:v copy -c:a copy "$output"
}

# extract files
# Maybe add install instructions if not installed?
extract () {
   if [[ -f $1 ]] ; then
      case $1 in
         *.tar.bz2)   tar xvjf $1    ;;
         *.tar.gz)    tar xvzf $1    ;;
         *.bz2)       bunzip2 $1     ;;
         *.rar)       unrar x $1     ;;
         *.gz)        gunzip $1      ;;
         *.tar)       tar xvf $1     ;;
         *.tbz2)      tar xvjf $1    ;;
         *.tgz)       tar xvzf $1    ;;
         *.zip)       unzip $1       ;;
         *.Z)         uncompress $1  ;;
         *.7z)        7z x $1        ;;
         *)           echo "don't know how to extract '$1'..." ;;
      esac
   else
      echo "'$1' is not a valid file!"
   fi
}

# cdup <number>
# cds <number> of times up
# cd 3 == cd ../../..
cdup(){
   local d=""
   limit=$1
   for ((i=1 ; i <= limit ; i++))
   do
      d=$d/..
   done
   d=$(echo $d | sed 's/^\///')
   if [[ -z "$d" ]]; then
      d=..
   fi
   cd $d
}

# easier column printing with awk
fawk() {
   cmd="awk '{print \$${1}${last}}'"
   eval $cmd
}

# mkdir & cd
mkcd() {
   if [[ $# != 1 ]]; then
      echo "Usage: mkcd <dir>"
   else
      mkdir -p $1 && cd $1
   fi
}

# cygwin specific, opens windows explorer for a given path
# if the path is not given, pwd will be used
# todo: Maybe a *nix version of this?
if [[ "$OSTYPE" == "cygwin" ]]; then
  explore() {
     if [[ "-"$1"-" = "--" ]]; then
        local exp=`pwd`
     else
        local exp=$1
     fi
     cygstart explorer.exe /e,`cygpath -w $exp`
  }
fi

# Calculate something
# calc 1+1
calc() {
    echo "scale=2;$@" | bc;
}

# to take a note: note your note
# to clear: note -c
# to view notes: note
note () {
   #if file doesn't exist, create it
   [[ -f $HOME/.notes ]] || touch $HOME/.notes

   #no arguments, print file
   if [[ $# = 0 ]]; then
          cat $HOME/.notes
   #clear file
   elif [[ $1 = -c ]]; then
      > $HOME/.notes
   #add all arguments to file
   else
      echo "$@" >> $HOME/.notes
   fi
}


# test if a file should be opened normally, or as root (vi)
reqroot () {
  count=0;
  for arg in "$@"; do
    if [[ ! "$arg" =~ '-' ]]; then count=$(($count+1)); fi;
  done;
  echo $count;
}

# replaces vi with vim and checks if the file
# requires root, if it does, it prompts to edit as root
vi () {
  if [[ `reqroot "$@"` > 1 ]]; then /usr/bin/vim $@;
  elif [[ $1 = '' ]]; then /usr/bin/vim;
  elif [[ ! -f $1 ]] || [[ -w $1 ]]; then /usr/bin/vim $@;
  else
    echo -n "File is readonly. Edit as root? (Y/n): "
    read -n 1 yn; echo;
    if [[ "$yn" = 'n' ]] || [[ "$yn" = 'N' ]]; then /usr/bin/vim $*;
    else sudo /usr/bin/vim $*;
    fi
  fi
}

# Creates an archive from given directory
mktar() { tar cvf  "${1%%/}.tar"     "${1%%/}/"; }
mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }
mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }

# Touchscreen toggling
touchscreen() {
  local devid="$(xinput | grep Touchscreen | awk '{ print $5 }' | awk -F '=' '{ print $2 }')"
  case "$1" in
    "off")
      xinput set-prop $devid 'Device Enabled' 0
      ;;
    *)
      xinput set-prop $devid 'Device Enabled' 1
      ;;
  esac
}

# Add defined in bash to ~/.bash_functions
addfunction() { declare -f $1 >> ~/.bash_functions ; }

# pretend to be busy in office to enjoy a cup of coffee
allhackingandshit()
{
  cat /dev/urandom | hexdump -C | grep --color=auto "ca fe"
}

hgg()
{
    if [[ $# -lt 1 ]] || [[ $# -gt 1 ]]; then
        echo "search bash history"
        echo "usage: mg [search pattern]"
    else
        history | grep -i $1 | grep -v hg
    fi
}

# Lists unique IPs currently connected to
# logged-in system & how many concurrent
# connections each IP has
connections()
{
  "netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n"
}

# Reminder for whatever whenever
remindme()
{
  sleep $1 && zenity --info --text "$2" &
}

# google search
google() {
  if [[ $1 ]]; then
    q="$@"
    q=$(echo ${q//[^a-zA-Z0-9]/+})
    if [[ "$OSTYPE" == "cygwin" ]]; then
      cygstart firefox -new-tab "https://www.google.com/search?q="$q;
    else
      firefox -new-tab "https://www.google.com/search?q="$q;
    fi
  else
    echo 'Usage: google seach terms';
  fi
}

# out puts the pid of the first grepped process
greppid () {
  local context=0
  local proc=$1
  if [[ "$1" == "--context" ]]; then
    context=1
    proc=$2
  else
    if [[ "$2" == "--context" ]]; then
      context=1
    fi
  fi

  if [[ "$context" == "1" ]]; then
    ps aux | grep $proc | head -n 1
  else
    ps aux | grep $proc | head -n 1 | awk '{ print $2 }'
  fi
}


ask() {
  read -p "$@ [y/N] " ans
  case "$ans" in
    y|Y|yes|Yes) return 0;;
    *) return 1;;
  esac
}


#### docker functions
# docker_run_attach() {
  # docker run -it --name my-running-irssi -e TERM -u $(id -u):$(id -g) \
    # --log-driver=none \
    # -v $HOME/.irssi:/home/user/.irssi:ro \
    # -v /etc/localtime:/etc/localtime:ro \
    # irssi"
# }
